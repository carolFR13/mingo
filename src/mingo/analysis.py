from mingo import Database
from sqlalchemy import select, Subquery, Select, Float
from sqlalchemy import func
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from matplotlib.backends.backend_pgf import PdfPages
from typing import Any, Sequence, Literal
from dataclasses import dataclass
import pandas as pd
import numpy as np


@dataclass
class Plot_config:
    """
    Configuration menu for plots generated by plot_dist and plot_stats

    :param title: Figure title, common for all subplots
    :param label: Label describing the property being ploted
    :param xscale: Scale to be used in the x axis
    :param yscale: Scale to be used in the y axis
    :param report_name: File name for report
    """

    title: str = ""
    label: str = ""
    xscale: Literal["linear", "log", "symlog", "logit"] = "linear"
    yscale: Literal["linear", "log", "symlog", "logit"] = "linear"
    report_name: str = "report.pdf"


class Base:
    """
    Base class for analysis utilities

    :param db: Database object
    """
    __name__ = "Base"

    def __init__(self, db: Database) -> None:

        # Database objects
        self.db = db
        self.config = db.config.c
        self.plane = db.plane.c
        self.event = db.event.c
        self.hit = db.hit.c

        # Data storage
        self.dist_data: dict[str, dict[float, Any]] = {}
        self.stats_data: dict[str, pd.DataFrame] = {}

        # Plot configuration
        self.plot_config = Plot_config()

        return None

    def distribution(self, id: int, label: str, **kwargs) -> None:
        """
        Distribution of given property as function of the initial energy
        of the primary cosmic ray.

        Specific behavior is defined by the _dist_tmp and _dist_stmt methods.

        Results are saved to self.dist_data

        :param id: ID of desired detector configuration
        :param label: Title for associated plots
        """

        R = kwargs["R"] if "R" in kwargs else None
        plane_num = kwargs["plane_num"] if "plane_num" in kwargs else None

        self.dist_data[label] = {}

        with self.db.engine.connect() as conn:

            energies = conn.execute(select(self.event.e_0)
                                    .where(self.event.fk_config == id)
                                    .distinct()
                                    .order_by(self.event.e_0))

            for energy, in energies:

                tmp = self._dist_tmp(id, energy, plane_num, R)
                stmt = self._dist_stmt(tmp, id, energy)

                _result = conn.execute(stmt).fetchall()

                _data = np.array([
                    [val, count] for val, count in conn.execute(stmt)
                ])

                if _result != []:
                    self.dist_data[label][energy] = _data.swapaxes(0, 1)

        return None

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> None | Subquery:
        """
        Implementation of the distribution's subquery for each specific
        property

        :param id: ID of desired detector configuration
        :param energy: Initial energy of primary cosmic ray
        :param plane_num: Plane number (First is 1, last is 4)
        :param R: Rounding factor
        """

        raise NotImplementedError()

    def _dist_stmt(self, tmp: None | Subquery,
                   id: int, energy: float) -> Select[tuple[Any, int]]:
        """
        Implementation of the distribution's query for each specific property

        :param tmp: Temporary table to be used by the query
        :param id: ID of desired detector configuration
        :param energy: Initial energy of primary cosmic ray
        """

        raise NotImplementedError()

    def stats(self, id: int, label: str, **kwargs) -> None:
        """
        Statistical descriptors of the distribution of a property as function
        of the initial energy of the primary cosmic ray.

        Specific behavior is defined by the _stats_tmp method.

        Results are saved to self.stats_data.

        :param id: ID of desired detector configuration
        :param label: Title for associated plots
        :param plane_num: Plane number
        """

        plane_num = kwargs["plane_num"] if "plane_num" in kwargs else None

        tmp = self._stats_tmp(id, plane_num)

        _tmp = (
            select(tmp.c.e_0.label("e_0"),
                   tmp.c.val.label("val"),
                   func.avg(tmp.c.val, type_=Float)
                   .over(tmp.c.e_0)
                   .label("avg")).alias("_tmp")
        )

        _func_std = func.sqrt(func.sum(func.pow(_tmp.c.val - _tmp.c.avg, 2)) /
                              func.count(_tmp.c.val), type_=Float)

        _func_skewness = (
            func.sum(func.pow(_tmp.c.val - _tmp.c.avg, 3, type_=Float)) /
            (func.count(_tmp.c.val) * func.pow(_func_std, 3, type_=Float)))

        # _func_skewness = (func.sum(func.pow(_tmp.c.val - _tmp.c.avg, 3)) /
        #                   (func.count(_tmp.c.val) * func.pow(_func_std, 3)))

        _func_kurtosis = (
            func.sum(func.pow(_tmp.c.val - _tmp.c.avg, 4, type_=Float)) /
            (func.count(_tmp.c.val) * func.pow(_func_std, 4, type_=Float)))

        # _func_kurtosis = (func.sum(func.pow(_tmp.c.val - _tmp.c.avg, 4)) /
        #                   (func.count(_tmp.c.val) * func.pow(_func_std, 4)))

        with self.db.engine.connect() as conn:

            result = pd.DataFrame(
                [
                    [e_0, avg, std, skew, kurt]
                    for e_0, avg, std, skew, kurt in conn.execute(
                        select(_tmp.c.e_0,
                               func.avg(_tmp.c.val, type_=Float),
                               _func_std,
                               _func_skewness,
                               _func_kurtosis).group_by(_tmp.c.e_0)
                    )
                ], columns=["e_0", "avg", "std", "skewness", "kurtosis"]
            )

            result["median"] = [
                median for e_0, median in conn.execute(
                    select(tmp.c.e_0,
                           func.percentile_cont(0.5)
                           .within_group(tmp.c.val)).group_by(tmp.c.e_0)
                )
            ]

        result["avg / std"] = result["avg"] / result["std"]

        self.stats_data[label] = result

        return None

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:
        """
        Implementation of stats' subquery for each specific property

        :param id: ID of desired detector configuration
        :param plane_num: Plane number
        """

        raise NotImplementedError

    def _make_figure(self,
                     figsize: tuple[int, int] = (12, 6)
                     ) -> tuple[Figure, Sequence[Axes]]:
        """
        Generate figure for distribution or stats plots with appropriate
        number of subplots

        :param figsize: Figure dimensions in inches
        :return fig: Matplotlib figure with subplots
        :return axs: Sequence of axes associated with subplots
        """

        match len(self.dist_data.keys()):
            case 1:
                fig, axs = plt.subplots(1, 1, figsize=figsize)
                axs = [axs]
            case 2:
                fig, axs = plt.subplots(1, 2, figsize=figsize)
            case 3:
                fig, axs = plt.subplots(2, 2, figsize=figsize)
            case 4:
                fig, axs = plt.subplots(2, 2, figsize=figsize)
            case 5:
                fig, axs = plt.subplots(2, 3, figsize=figsize)
            case 6:
                fig, axs = plt.subplots(2, 3, figsize=figsize)
            case _:
                raise ValueError("Too many values for a single figure")

        return fig, axs     # type: ignore

    def plot_distribution(self) -> Figure:
        """
        Generate distribution plots from data in self.dist_data

        Plot configuration is read from self.plot_config

        :return fig: Figure with distribution plots
        """

        xlim: float = 0
        ylim: float = 0

        fig, axs = self._make_figure()

        for ax, key in zip(axs, self.dist_data):

            for e, (val, count) in self.dist_data[key].items():
                ax.plot(val, count, label=f"{e:.0f} MeV")

            ax.set_xscale(self.plot_config.xscale)
            ax.set_yscale(self.plot_config.yscale)
            ax.set_title(key)
            ax.set_xlabel(self.plot_config.label)
            ax.legend()

            xlim = max(xlim, ax.get_xlim()[1])
            ylim = max(ylim, ax.get_ylim()[1])

        axs[0].set_ylabel("Number of events")
        fig.suptitle(self.plot_config.title)

        for ax in fig.get_axes():
            ax.set_xlim((None, xlim))
            ax.set_ylim((None, ylim))

        return fig

    def plot_stats(self) -> Figure:
        """
        Generate stats plots from data in self.stats_data.

        Each plot includes the mean, median and standard deviation of a certain
        property as function of the initial energy of the primary cosmic ray

        Plot configuration is read from self.plot_config

        :return fig: Figure with stats plots
        """

        xlim: float = 0
        ylim: float = 0

        fig, axs = self._make_figure()

        for ax, key in zip(axs, self.stats_data):

            data = self.stats_data[key]
            ax.plot(data["e_0"], data["avg"], label="Average")
            ax.fill_between(data["e_0"],
                            data["avg"] - data["std"],      # type: ignore
                            data["avg"] + data["std"],      # type: ignore
                            label="Standard deviation", alpha=0.2)
            ax.scatter(data["e_0"], data["median"], label="Median", c="orange")

            ax.set_title(key)
            ax.set_xlabel("Initial energy [MeV]")
            ax.legend()

            xlim = max(xlim, ax.get_xlim()[1])
            ylim = max(ylim, ax.get_ylim()[1])

        axs[0].set_ylabel(self.plot_config.label)
        fig.suptitle(self.plot_config.title)

        for ax in fig.get_axes():
            ax.set_xlim((None, xlim))
            ax.set_ylim((None, ylim))

        return fig

    def report_figure(self) -> Figure:
        """
        Generate pairs of distribution plots and stats tables.

        Data is read from self.dist_data and self.stats_data

        :return fig: Figure with plots and tables
        """

        # Figure configuration

        label_font = {"weight": "light", "size": "small"}
        base_color = "#aec7e8"
        font_color = "#21486e"

        xlim: float = 0
        ylim: float = 0

        fig = plt.figure(figsize=(8.3, 11.7), layout=None)
        spec = fig.add_gridspec(ncols=2,
                                nrows=3,
                                left=0.1,
                                right=0.95,
                                top=0.93,
                                bottom=0.07,
                                wspace=0.1,
                                hspace=0.2,
                                width_ratios=[1, 1.2])

        for idx, key in enumerate(self.dist_data):

            dist = self.dist_data[key]
            stats = self.stats_data[key].round(1)

            ax_plot = fig.add_subplot(spec[idx, 0])
            ax_table = fig.add_subplot(spec[idx, 1])

            # Plot distribution
            for e, (val, count) in dist.items():
                ax_plot.plot(val, count, label=f"{e:.0f} MeV", linewidth=1)

            ax_plot.set_xscale(self.plot_config.xscale)
            ax_plot.set_yscale(self.plot_config.yscale)
            ax_plot.set_xlabel(self.plot_config.label,
                               fontdict=label_font, labelpad=1)
            ax_plot.set_ylabel("Number of events",
                               fontdict=label_font, labelpad=1)
            ax_plot.tick_params(labelsize="x-small")
            ax_plot.legend(fontsize="xx-small")

            xlim = max(xlim, ax_plot.get_xlim()[1])
            ylim = max(ylim, ax_plot.get_ylim()[1])

            # Add table
            ax_table.axis("off")
            ax_table.set_title(key, fontsize="medium", y=1, pad=-25)
            ax_table.table(
                cellText=stats.values,
                colLabels=[r"$E_0$", r"$\mu$", r"$\sigma$", r"$S$",
                           r"$\kappa$", "Med", r"$\mu / \sigma$"],
                loc="center",
                cellLoc="center",
                rowLoc="center",
                colColours=[base_color] * len(stats.columns)
            )

        fig.suptitle(self.plot_config.title, weight="bold", color=font_color)

        for ax in fig.get_axes():
            if ax.axison:
                ax.set_xlim((None, xlim))
                ax.set_ylim((None, ylim))

        return fig

    def __call__(self, id: int, label: str) -> None:
        """
        Executes the distribution and stats methods in one call

        :param id: ID of desired detector configuration
        :param label: Title for associated plots
        """

        self.distribution(id, label)
        self.stats(id, label)

        return None


class Hit_distribution(Base):
    """
    Number of hits per event as function of the initial energy of the primary
    cosmic ray

    :param db: Database object
    """

    __name__ = "Hit distribution"

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        self.plane_number = None

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Number of hits per event"
        self.plot_config.title = (
            "Distribution of hits per event as a function of initial energy"
        )
        self.plot_config.report_name = "hit-distribution.pdf"

        return None

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label)

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (
            select(self.event.e_0.label("e_0"),
                   self.event.n_hits.label("val"))
            .where(self.event.fk_config == id)
            .alias("tmp")
        )

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label)

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        return None

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:

        if grouped:
            return (select(self.event.n_hits, func.count(self.event.e_0))
                    .where(self.event.fk_config == id)
                    .where(self.event.e_0 == energy)
                    .group_by(self.event.n_hits)
                    .order_by(self.event.n_hits))
        else:
            return (select(self.event.n_hits)
                    .where(self.event.fk_config == id)
                    .where(self.event.e_0 == energy))


class Shower_depth(Base):
    """
    Average height of the electrons generated by a primary cosmic ray as
    function of its initial energy

    :param db: Database object
    """

    __name__ = "Shower depth"

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        self.plane_number = None

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Average shower depth [mm]"
        self.plot_config.title = (
            "Average shower depth as a function of initial energy"
        )
        self.plot_config.report_name = "shower-depth.pdf"

        return None

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label, R=5)

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        _stmt = (
            select(self.event.e_0,
                   (func.round(func.avg(self.hit.z, type_=Float) / R) * R)
                   .label("avg_z"))
            .select_from(self.db.hit
                         .join(self.db.event,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id)
            .group_by(self.event.id)
            .alias("tmp"))

        return _stmt

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:

        if tmp is None:
            raise TypeError("Expected tmp of type Subquery, got None")

        if grouped: 
            return (select(tmp.c.avg_z, func.count(tmp.c.avg_z))
                    .where(tmp.c.e_0 == energy)
                    .group_by(tmp.c.avg_z))
        else:
            return(select(tmp.c.avg_z)
                    .where(tmp.c.e_0 == energy))

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                func.avg(self.hit.z, type_=Float).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label)
    

class Shower_waist(Base):
    """
    Maximum distance reached in the last detector by the electrons generated 
    by a primary cosmic ray as function of its initial energy

    :param db: Database object
    """

    __name__ = "Shower Waist"

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        self.plane_number = None

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Showe waist [mm]"
        self.plot_config.title = (
            "Shower waist as a function of initial energy"
        )
        self.plot_config.report_name = "shower-waist.pdf"

        return None

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label, R=5)

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        _stmt = (
            select(self.event.e_0,
                   (func.round(func.max(func.sqrt(self.hit.x * self.hit.x + self.hit.y * self.hit.y)) / R) * R)
                   .label("max_dist"))
            .select_from(self.db.hit
                         .join(self.db.event,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id)
            .group_by(self.event.id)
            .alias("tmp"))

        return _stmt

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:
        if tmp is None:
            raise TypeError("Expected tmp of type Subquery, got None")
        
        if grouped:
            return (select(tmp.c.max_dist, func.count(tmp.c.max_dist))
                    .where(tmp.c.e_0 == energy)
                    .group_by(tmp.c.max_dist))
        else:
            return (select(tmp.c.max_dist)
                    .where(tmp.c.e_0 == energy))


    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                func.max(func.sqrt(self.hit.x * self.hit.x + self.hit.y * self.hit.y)).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label)


class Average_time(Base):
    """
    Average time of the electrons generated by a primary cosmic ray as
    function of its initial energy. Not included in the report.

    :param db: Database object
    """

    __name__ = "Average time"

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        self.plane_number = None

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Average time [ns]"
        self.plot_config.title = (
            "Average time as a function of initial energy"
        )
        self.plot_config.report_name = "average-time.pdf"

        return None

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label, R=5)

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        _stmt = (
            select(self.event.e_0,
                   (func.round(func.avg(self.hit.t, type_=Float) / R) * R)
                   .label("avg_t"))
            .select_from(self.db.hit
                         .join(self.db.event,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id)
            .group_by(self.event.id)
            .alias("tmp"))

        return _stmt

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:

        if tmp is None:
            raise TypeError("Expected tmp of type Subquery, got None")

        if grouped: 
            return (select(tmp.c.avg_t, func.count(tmp.c.avg_t))
                    .where(tmp.c.e_0 == energy)
                    .group_by(tmp.c.avg_t))
        else:
            return(select(tmp.c.avg_t)
                    .where(tmp.c.e_0 == energy))

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                func.avg(self.hit.t, type_=Float).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label)


class Plane_hits(Base):
    """
    Number of hits per event on a given plane as function of the initial
    energy of the primary cosmic ray

    :param db: Database object
    :param plane: Plane number (First is 1 last is 4)
    """

    def __init__(self, db: Database, plane: int) -> None:

        super().__init__(db)

        self.__name__ = f"Plane {plane} hits"

        self.plane_number = plane

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = f"Number of hits in plane {self.plane_number}"
        self.plot_config.title = (
            "Number of hits per event as a function of initial energy: "
            f"Plane {self.plane_number}"
        )
        self.plot_config.report_name = f"hits-plane-{self.plane_number}.pdf"

        return None

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        return (
            select((func.count(self.hit.id).label("hits")))
            .select_from(self.db.hit
                         .join(self.db.event,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id,
                   self.event.e_0 == energy,
                   self.hit.plane == plane_num)
            .group_by(self.event.id)
            .alias("tmp")
        )

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:

        if tmp is None:
            raise TypeError("Expected tmp of Subquery type, got None")
        
        if grouped:
            return (select(tmp.c.hits, func.count(tmp.c.hits))
                    .group_by(tmp.c.hits))
        else:
            return (select(tmp.c.hits))


    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label, plane_num=self.plane_number)

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                       func.count(self.hit.id).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id, self.hit.plane == plane_num)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label, plane_num=self.plane_number)
    

class Scattering(Base):
    """
    Average distance between particle impacts and the center of a given plane
    as function of the initial energy of the primary cosmic ray

    :param db: Database object
    :param plane: Plane number (First is 1, last is 4)
    """

    def __init__(self, db: Database, plane: int) -> None:

        super().__init__(db)

        self.__name__ = f"Scattering plane {plane}"

        self.plane_number = plane

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = (
            f"Average distance to center of plane {self.plane_number} [mm]"
        )
        self.plot_config.title = (
            "Hit scattering as a function of initial energy: "
            f"Plane {self.plane_number}"
        )
        self.plot_config.report_name = (
            f"scattering-plane-{self.plane_number}.pdf"
        )

        return None

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        return (
            select(self.event.id.label("id"),
                   self.event.e_0.label("e_0"),
                   (func.round(func.avg(func.sqrt(
                       self.hit.x * self.hit.x + self.hit.y * self.hit.y
                   )) * R) / R).label("avg_R"))
            .select_from(self.db.event
                         .join(self.db.hit,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id,
                   self.event.e_0 == energy,
                   self.hit.plane == plane_num)
            .group_by(self.event.id)
            .alias("tmp")
        )

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:
        
        if tmp is None:
            raise TypeError("Expected tmp of type Subquery, got None")
        
        if grouped:
            return (select(tmp.c.avg_R, func.count(tmp.c.avg_R))
                    .group_by(tmp.c.avg_R))
        else:
            return (select(tmp.c.avg_R))

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label,
                                    R=0.2, plane_num=self.plane_number)

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                       func.avg(func.sqrt(
                           self.hit.x * self.hit.x + self.hit.y * self.hit.y
                       )).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id, self.hit.plane == plane_num)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label, plane_num=self.plane_number)
    

class Plane_time(Base):
    """
    Average time of electrons impacting in a given plane as function of 
    the initial energy of the primary cosmic ray. Not included in the report

    :param db: Database object
    :param plane: Plane number (First is 1, last is 4)
    """

    def __init__(self, db: Database, plane: int) -> None:

        super().__init__(db)

        self.__name__ = f"Average time: Plane {plane}"

        self.plane_number = plane

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = (
            f"Average time of plane {self.plane_number} [ns]"
        )
        self.plot_config.title = (
            "Average time as a function of initial energy: "
            f"Plane {self.plane_number}"
        )
        self.plot_config.report_name = (
            f"Average-time-plane-{self.plane_number}.pdf"
        )

        return None

    def _dist_tmp(self, id: int, energy: float,
                  plane_num: int | None, R: float | None) -> Subquery | None:

        return (
            select(self.event.id.label("id"),
                   self.event.e_0.label("e_0"),
                   (func.round(func.avg(self.hit.t) * R) / R).label("avg_t"))
            .select_from(self.db.event
                         .join(self.db.hit,
                               self.event.id == self.hit.fk_event))
            .where(self.event.fk_config == id,
                   self.event.e_0 == energy,
                   self.hit.plane == plane_num)
            .group_by(self.event.id)
            .alias("tmp")
        )

    def _dist_stmt(self, tmp: Subquery | None,
                   id: int, energy: float, grouped: bool = True) -> Select[tuple[Any, int]]:
        
        if tmp is None:
            raise TypeError("Expected tmp of type Subquery, got None")
        
        if grouped:
            return (select(tmp.c.avg_t, func.count(tmp.c.avg_t))
                    .group_by(tmp.c.avg_t))
        else:
            return (select(tmp.c.avg_t))

    def distribution(self, id: int, label: str, **kwargs) -> None:
        return super().distribution(id, label,
                                    R=0.2, plane_num=self.plane_number)

    def _stats_tmp(self, id: int, plane_num: int | None) -> Subquery:

        return (select(self.event.e_0.label("e_0"),
                       func.avg(self.hit.t).label("val"))
                .select_from(self.db.event
                             .join(self.db.hit,
                                   self.event.id == self.hit.fk_event))
                .where(self.event.fk_config == id, self.hit.plane == plane_num)
                .group_by(self.event.id)
                .alias("tmp"))

    def stats(self, id: int, label: str, **kwargs) -> None:
        return super().stats(id, label, plane_num=self.plane_number)
   

def report(db: Database,
           path: str,
           scale: Literal["linear", "log", "symlog", "logit"] = "linear"
           ) -> None:
    """
    Generate complete report

    :param db: Database object
    :param path: Report's path
    :param scale: Y axis' scale for the distribution plots
    """

    ids: list[int] = []
    titles: list[str] = []

    stmt = select(db.config.c.id, db.config.c.fk_p1,
                  db.config.c.fk_p2, db.config.c.fk_p3, db.config.c.fk_p4)

    with db.engine.connect() as conn:

        for id, p1, p2, p3, p4 in conn.execute(stmt):

            # Add configuration ID
            ids.append(id)

            # Generate title from plane ids
            title = ""
            for idx, id in enumerate([p1, p2, p3, p4]):
                thick, = conn.scalars(select(db.plane.c.abs_thick)
                                      .where(db.plane.c.id == id))
                title += "NULL" if thick is None else f"{thick:.1f}"

                if idx != 3:
                    title += " - "

            titles.append(title)

    obj_list = [Hit_distribution(db), Shower_depth(db), Shower_waist(db), 
                Plane_hits(db, 2), Plane_hits(db, 3), Plane_hits(db, 4), 
                Scattering(db, 2), Scattering(db, 3), Scattering(db, 4),
                ]

    with PdfPages(path) as file:
        for obj in obj_list:
            obj.plot_config.yscale = scale
            for id, title in zip(ids, titles):
                print(f"Generating {obj.__name__} report: {title}")
                obj(id, title)
            file.savefig(obj.report_figure())

    return None


class Matrix:
    '''
    Matrix base class for statistical study. 

    :param db: Database object
    '''

    def __init__(self, db: Database) -> None:

        # Database object
        self.db = db
        self.config = db.config.c
        self.plane = db.plane.c
        self.event = db.event.c
        self.hit = db.hit.c

        # Data storage
        self.variables_data: dict[str, np.array] = {}
        self.matrix_data: np.array | None = None

        return None


    def variables(self, id: int, energy: float, **kwargs) -> dict:

        '''
        Variables implementation for the matrix rows. 
        
        :param id: ID of the desired detector configuration
        :param energy: Energy associated to the desired variables 
        '''

        R = kwargs["R"] if "R" in kwargs else None

        obj_list = [
            ('hit_dist', Hit_distribution(self.db)), 
            ('shower_depth', Shower_depth(self.db)), 
            ('shower_waist', Shower_waist(self.db)),
            ('average time', Average_time(self.db)),
            ('plane_hits 2', Plane_hits(self.db, 2)),
            ('plane_hits 3', Plane_hits(self.db, 3)),
            ('plane_hits 4', Plane_hits(self.db, 4)), 
            ('scattering 2', Scattering(self.db, 2)),
            ('scattering 3', Scattering(self.db, 3)), 
            ('scattering 4', Scattering(self.db, 4)),
            ('plane_time 2', Plane_time(self.db, 2)),
            ('plane_time 3', Plane_time(self.db, 3)),
            ('plane_time 4', Plane_time(self.db, 4))
            ]
    
        self.variables_data = {}

        with self.db.engine.connect() as conn:

            for label, obj in obj_list:

                plane_num = obj.plane_number 
                _tmp = obj._dist_tmp(id, energy, plane_num, R = R)
                _stmt = obj._dist_stmt(_tmp, id, energy, grouped = False)

                _result = conn.execute(_stmt).fetchall()

                _data = np.array([
                    row[0] for row in conn.execute(_stmt)])
                    
                if _result != []:
                    self.variables_data[label] = _data

        return self.variables_data
    
    def variables_list(self):
        '''
        returns the variables name's list
        '''

        v = ['hit_dist', 'shower_depth', 'shower_waist', 'average time',
            'plane_hits 2', 'plane_hits 3', 'plane_hits 4',
            'scattering 2','scattering 3', 'scattering 4',
            'plane_time 2', 'plane_time 3', 'plane_time 4']
        
        return v

    def get_matrix(self, id: int, energy: float, **kwargs) -> np.ndarray:

        '''
        Matrix getter method to obtain the variables in a matrix of lenght 
        (num_events x num_variables). If the variable's len is not num_events, the 
        variable is not included.
        '''

        R = kwargs["R"] if "R" in kwargs else None

        self.variables(id, energy, R = R)
        n_rows = len(next(iter(self.variables_data.values())))
        matrix = np.zeros((n_rows, len(self.variables_data)), dtype=float)

        for col_idx, (label, data) in enumerate(self.variables_data.items()):
            if len(data) != n_rows:
                # print(f'The variable {label} does not have {n_rows} elements, it has {len(data)}.')
                matrix = np.delete(matrix, -1, axis=1) 
            else:
                matrix[:, col_idx] = data

        self.matrix_data = matrix
        
        return matrix
    
    def get_std_matrix(self, id: int, energy: float, **kwargs) -> np.ndarray:


        matrix = self.get_matrix(id, energy, **kwargs)
        n_rows, _ =  self.matrix_data.shape

        
        std_matrix = (1/n_rows) * np.matmul(matrix.transpose(),matrix)

        return std_matrix


    def get_eigenvalues(self, id, energy, **kwargs):

        '''
        Computation of the singular value decomposition (SVD) to obtain the singular
        values of a non-square matrix (equivalent to eigenvalues).

        We compute it by using the reduced form of SVD, following 
        Daniel Peña's approach in 'Análisis de datos multivariantes'.
        '''

        matrix = self.get_std_matrix(id, energy, **kwargs)
        singular_values = np.linalg.svd(matrix, full_matrices=False, compute_uv=False)

        return singular_values**2


    def get_eigenvectors(self, id, energy, **kwargs):

        '''
        Computation of the left singular values (analogous to eigenvectors)
        of the non-square matrix.

        We are interested in the eigenvectos of matrix.transpose() @ matrix
        since we want to get an eigenvector for each variable.
        '''

        matrix = self.get_std_matrix(id, energy, **kwargs)
        _ , _ , vh = np.linalg.svd(matrix, full_matrices=False)
        left_singular_vectors = vh.T  # Transpose of the right singular vectors

        #the matrix columns are the eigenvectors
        return left_singular_vectors


class Normaliced_matrix(Matrix):

    def get_matrix(self, id: int, energy: float, **kwargs) -> np.ndarray:

        '''
        Matrix getter method to obtain the variables in a matrix of lenght 
        (num_events x num_variables). If the variable's len is not num_events, the 
        variable is not included.
        
        Variables in this case would be normaliced (by substracting its mean value).
        '''
        super().get_matrix(id, energy, **kwargs)
        n_rows, n_cols =  self.matrix_data.shape
        matrix = np.zeros((n_rows, n_cols), dtype=float)


        for col_idx, (label, data) in enumerate(self.variables_data.items()):
            if len(data) != n_rows:
                # print(f'The variable {label} does not have {n_rows} elements, it has {len(data)}.')
                pass
            else:
                mean = np.mean(data)
                matrix[:, col_idx] = data - mean

        self.matrix_data = matrix

        return self.matrix_data


class Standardised_matrix(Matrix):
        
    def get_matrix(self, id: int, energy: float, **kwargs) -> np.ndarray:

        '''
        Matrix getter method to obtain the variables in a matrix of lenght 
        (num_events x num_variables). If the variable's len is not num_events, the 
        variable is not included.

        Variables in this case would be standardised (by substracting its mean value and 
        dividing the result by its standar deviation).
        '''

        super().get_matrix(id, energy, **kwargs)
        n_rows, n_cols =  self.matrix_data.shape
        matrix = np.zeros((n_rows, n_cols), dtype=float)


        for col_idx, (label, data) in enumerate(self.variables_data.items()):
            if len(data) != n_rows:
                # print(f'The variable {label} does not have {n_rows} elements, it has {len(data)}.')
                pass
            else:
                mean = np.mean(data)
                std = np.std(data)
                matrix[:, col_idx] =  (data - mean)/std

        self.matrix_data = matrix

        return self.matrix_data